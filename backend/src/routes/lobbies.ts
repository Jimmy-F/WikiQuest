import { Router, Request, Response } from 'express';
import { supabase } from '../server';

const router = Router();

// Create a new lobby (Direct Invite or Public)
router.post('/create', async (req: Request, res: Response) => {
  try {
    const { userId, raceId, startArticle, endArticle, difficulty, isPublic = false, isRanked = true, maxPlayers = 2 } = req.body;

    // Validate maxPlayers
    const validMaxPlayers = Math.min(Math.max(2, maxPlayers), 10);

    // Create lobby
    const { data: lobby, error: lobbyError } = await supabase
      .from('battle_lobbies')
      .insert({
        host_id: userId,
        race_id: raceId,
        start_article: startArticle,
        end_article: endArticle,
        difficulty,
        is_public: isPublic,
        is_ranked: isRanked,
        max_players: validMaxPlayers,
        lobby_code: '', // Will be auto-generated by trigger
        status: 'waiting'
      })
      .select()
      .single();

    if (lobbyError) throw lobbyError;

    // Add host as first participant
    const { error: participantError } = await supabase
      .from('lobby_participants')
      .insert({
        lobby_id: lobby.id,
        user_id: userId,
        is_host: true,
        status: 'joined'
      });

    if (participantError) throw participantError;

    // Generate invite link
    const inviteLink = `${process.env.FRONTEND_URL || 'http://localhost:3001'}/battle/invite/${lobby.lobby_code}`;

    res.json({
      lobby,
      inviteLink,
      message: `Lobby created! Code: ${lobby.lobby_code}`
    });
  } catch (error: any) {
    console.error('Error creating lobby:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get lobby details by code
router.get('/:code', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;

    const { data: lobby, error: lobbyError } = await supabase
      .from('battle_lobbies')
      .select(`
        *,
        host:users!battle_lobbies_host_id_fkey(id, email)
      `)
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (lobbyError) throw lobbyError;

    // Get participants
    const { data: participants, error: participantsError } = await supabase
      .from('lobby_participants')
      .select(`
        *,
        user:users(id, email)
      `)
      .eq('lobby_id', lobby.id);

    if (participantsError) throw participantsError;

    res.json({
      lobby,
      participants: participants || []
    });
  } catch (error: any) {
    console.error('Error fetching lobby:', error);
    res.status(404).json({ error: 'Lobby not found' });
  }
});

// List public lobbies
router.get('/list/public', async (req: Request, res: Response) => {
  try {
    const { limit = 20 } = req.query;

    // Cleanup expired lobbies first
    await supabase.rpc('cleanup_expired_lobbies');

    // Get lobbies with participant count
    const { data: lobbies, error } = await supabase
      .from('battle_lobbies')
      .select(`
        *,
        host:users!battle_lobbies_host_id_fkey(id, email),
        participant_count:lobby_participants(count)
      `)
      .eq('is_public', true)
      .eq('status', 'waiting')
      .order('created_at', { ascending: false })
      .limit(Number(limit));

    if (error) throw error;

    // Filter out lobbies with no participants (orphaned lobbies)
    const activeLobbies = (lobbies || []).filter(lobby => {
      const participantCount = lobby.participant_count?.[0]?.count || 0;
      return participantCount > 0;
    });

    res.json({ lobbies: activeLobbies });
  } catch (error: any) {
    console.error('Error fetching public lobbies:', error);
    res.status(500).json({ error: error.message });
  }
});

// Join a lobby by code
router.post('/:code/join', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;
    const { userId } = req.body;

    // Get lobby
    const { data: lobby, error: lobbyError } = await supabase
      .from('battle_lobbies')
      .select('*')
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (lobbyError) throw lobbyError;

    // Check if lobby is still waiting
    if (lobby.status !== 'waiting') {
      return res.status(400).json({ error: 'Lobby is no longer accepting players' });
    }

    // Check if lobby is full
    const { count } = await supabase
      .from('lobby_participants')
      .select('*', { count: 'exact', head: true })
      .eq('lobby_id', lobby.id);

    if (count && count >= lobby.max_players) {
      return res.status(400).json({ error: 'Lobby is full' });
    }

    // Check if user already in lobby
    const { data: existing } = await supabase
      .from('lobby_participants')
      .select('*')
      .eq('lobby_id', lobby.id)
      .eq('user_id', userId)
      .single();

    if (existing) {
      return res.json({ message: 'Already in lobby', lobby });
    }

    // Add participant
    const { error: participantError } = await supabase
      .from('lobby_participants')
      .insert({
        lobby_id: lobby.id,
        user_id: userId,
        is_host: false,
        status: 'joined'
      });

    if (participantError) throw participantError;

    res.json({
      message: 'Joined lobby successfully',
      lobby
    });
  } catch (error: any) {
    console.error('Error joining lobby:', error);
    res.status(500).json({ error: error.message });
  }
});

// Toggle ready status
router.post('/:code/ready', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;
    const { userId } = req.body;

    // Get lobby
    const { data: lobby } = await supabase
      .from('battle_lobbies')
      .select('id')
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (!lobby) {
      return res.status(404).json({ error: 'Lobby not found' });
    }

    // Get current participant status
    const { data: participant } = await supabase
      .from('lobby_participants')
      .select('*')
      .eq('lobby_id', lobby.id)
      .eq('user_id', userId)
      .single();

    if (!participant) {
      return res.status(403).json({ error: 'Not in this lobby' });
    }

    // Toggle ready status
    const newStatus = participant.status === 'ready' ? 'joined' : 'ready';
    const readyAt = newStatus === 'ready' ? new Date().toISOString() : null;

    const { error } = await supabase
      .from('lobby_participants')
      .update({
        status: newStatus,
        ready_at: readyAt
      })
      .eq('lobby_id', lobby.id)
      .eq('user_id', userId);

    if (error) throw error;

    res.json({
      message: newStatus === 'ready' ? 'Marked as ready' : 'Unready',
      status: newStatus
    });
  } catch (error: any) {
    console.error('Error toggling ready:', error);
    res.status(500).json({ error: error.message });
  }
});

// Start battle (host only)
router.post('/:code/start', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;
    const { userId } = req.body;

    // Get lobby
    const { data: lobby } = await supabase
      .from('battle_lobbies')
      .select('*')
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (!lobby) {
      return res.status(404).json({ error: 'Lobby not found' });
    }

    // Verify user is host
    if (lobby.host_id !== userId) {
      return res.status(403).json({ error: 'Only the host can start the battle' });
    }

    // Get participants
    const { data: participants } = await supabase
      .from('lobby_participants')
      .select('*')
      .eq('lobby_id', lobby.id);

    if (!participants || participants.length < 2) {
      return res.status(400).json({ error: 'Need at least 2 players to start' });
    }

    // Check if all players are ready
    const allReady = participants.every(p => p.status === 'ready');
    if (!allReady) {
      return res.status(400).json({ error: 'All players must be ready' });
    }

    // Create battle match
    const player1 = participants.find(p => p.is_host);
    const player2 = participants.find(p => !p.is_host);

    // Get MMR for both players
    const { data: stats1 } = await supabase
      .from('battle_stats')
      .select('mmr')
      .eq('user_id', player1!.user_id)
      .single();

    const { data: stats2 } = await supabase
      .from('battle_stats')
      .select('mmr')
      .eq('user_id', player2!.user_id)
      .single();

    const { data: match, error: matchError } = await supabase
      .from('battle_matches')
      .insert({
        match_type: 'real_time',
        race_id: lobby.race_id,
        start_article: lobby.start_article,
        end_article: lobby.end_article,
        difficulty: lobby.difficulty,
        player1_id: player1!.user_id,
        player1_mmr: stats1?.mmr || 1000,
        player2_id: player2!.user_id,
        player2_mmr: stats2?.mmr || 1000,
        player2_is_bot: false,
        is_ranked: lobby.is_ranked !== false,
        status: 'in_progress',
        started_at: new Date().toISOString()
      })
      .select()
      .single();

    if (matchError) throw matchError;

    // Update lobby status
    await supabase
      .from('battle_lobbies')
      .update({
        status: 'in_progress',
        battle_match_id: match.id,
        started_at: new Date().toISOString()
      })
      .eq('id', lobby.id);

    // Update participants to racing
    await supabase
      .from('lobby_participants')
      .update({ status: 'racing' })
      .eq('lobby_id', lobby.id);

    res.json({
      message: 'Battle started!',
      match,
      lobby
    });
  } catch (error: any) {
    console.error('Error starting battle:', error);
    res.status(500).json({ error: error.message });
  }
});

// Leave lobby
router.post('/:code/leave', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;
    const { userId } = req.body;

    // Get lobby
    const { data: lobby } = await supabase
      .from('battle_lobbies')
      .select('*')
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (!lobby) {
      return res.status(404).json({ error: 'Lobby not found' });
    }

    // Remove participant
    const { error } = await supabase
      .from('lobby_participants')
      .delete()
      .eq('lobby_id', lobby.id)
      .eq('user_id', userId);

    if (error) throw error;

    // If host left, cancel lobby or transfer host
    if (lobby.host_id === userId) {
      // Get remaining participants
      const { data: remaining } = await supabase
        .from('lobby_participants')
        .select('*')
        .eq('lobby_id', lobby.id);

      if (!remaining || remaining.length === 0) {
        // No one left, cancel lobby
        await supabase
          .from('battle_lobbies')
          .update({ status: 'cancelled' })
          .eq('id', lobby.id);
      } else {
        // Transfer host to first remaining player
        const newHost = remaining[0];
        await supabase
          .from('battle_lobbies')
          .update({ host_id: newHost.user_id })
          .eq('id', lobby.id);

        await supabase
          .from('lobby_participants')
          .update({ is_host: true })
          .eq('lobby_id', lobby.id)
          .eq('user_id', newHost.user_id);
      }
    }

    res.json({ message: 'Left lobby successfully' });
  } catch (error: any) {
    console.error('Error leaving lobby:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get lobby status (for polling)
router.get('/:code/status', async (req: Request, res: Response) => {
  try {
    const { code } = req.params;
    const { userId } = req.query;

    const { data: lobby } = await supabase
      .from('battle_lobbies')
      .select('*')
      .eq('lobby_code', code.toUpperCase())
      .single();

    if (!lobby) {
      return res.status(404).json({ error: 'Lobby not found' });
    }

    const { data: participants } = await supabase
      .from('lobby_participants')
      .select(`
        *,
        user:users(id, email)
      `)
      .eq('lobby_id', lobby.id);

    const userInLobby = participants?.some(p => p.user_id === userId);

    res.json({
      lobby,
      participants: participants || [],
      userInLobby,
      canStart: lobby.host_id === userId &&
                (participants?.length || 0) === lobby.max_players &&
                (participants?.every(p => p.status === 'ready') || false)
    });
  } catch (error: any) {
    console.error('Error fetching lobby status:', error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
